<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Debug Map</title>
  <style>
    body { background:#0B1020; color:#D7E3FF; font-family: ui-sans-serif, system-ui, -apple-system; }
    .panel { background:#11172B; border:1px solid #1B2440; padding:16px; margin:12px; border-radius:8px; }
    canvas { width:100%; height:420px; background:#050814; border:1px solid #1B2440; border-radius:6px; }
    .row { display:flex; gap:16px; }
    .col { flex:1; }
    .pill { padding:4px 8px; border-radius:12px; background:#0F162A; border:1px solid #1B2440; margin:4px 0; }
    .pill[id="wsStatus"] { display: inline-block; }
  </style>
</head>
<body>
  <div class="panel">
    <h2>Debug <span class="pill" id="wsStatus" title="WebSocket connection status" style="margin-left: 8px; font-size: 14px; font-weight: normal;">WebSocket: Connecting...</span></h2>
    <div class="row" style="align-items:center">
      <button id="restart" title="Reset mission state to defaults">Restart Mission</button>
      <div>
        <label for="mission">Mission:</label>
        <select id="mission" title="Select mission scenario">
          <option value="patrol">Patrol - Blue vs Single Red</option>
          <option value="surface_training">Surface Training (assets)</option>
        </select>
      </div>
      <div class="pill" style="margin-left: 8px;">
        Maint Spawns: <span id="maintState">ON</span>
        <button id="toggleMaint" style="margin-left:8px;">Toggle</button>
      </div>
      <div class="pill" style="margin-left: 8px;">
        Player Visual 100%: <span id="playerVisualState">OFF</span>
        <button id="togglePlayerVisual" style="margin-left:8px;">Toggle</button>
      </div>
      <div class="pill" style="margin-left: 8px;">
        Enemy Visual 100%: <span id="enemyVisualState">OFF</span>
        <button id="toggleEnemyVisual" style="margin-left:8px;">Toggle</button>
      </div>
    </div>
    <div class="row">
      <div class="col">
        <canvas id="map" width="720" height="420" title="Ownship-centered truth positions"></canvas>
      </div>
      <div class="col">
        <div class="pill">Ownship: <span id="own"></span></div>
        <div class="pill" style="margin-top: 8px; background: #1A1A2E; border-color: #60A5FA;">Noise Info</div>
        <div id="noiseInfo" style="font-size: 12px; margin-top: 4px;"></div>
        <div id="list"></div>
        <div style="margin-top: 16px;">
          <div class="pill" style="background: #1A1A2E; border-color: #FF4444;">Torpedo Events</div>
          <div id="torpedoEvents" style="max-height: 120px; overflow-y: auto; font-size: 12px;"></div>
        </div>
        <div style="margin-top: 16px;">
          <div class="pill" style="background: #1A1A2E; border-color: #4F46E5;">Contact History</div>
          <div id="contactHistory" style="max-height: 180px; overflow-y: auto; font-size: 12px;"></div>
        </div>
      </div>
    </div>
    <div style="margin-top: 16px;">
      <div class="pill" style="background: #1A1A2E; border-color: #60A5FA;">Ships (Truth JSON)</div>
      <pre id="shipsJson" style="background:#0E1326; border:1px solid #1B2440; padding:8px; border-radius:6px; color:#BBD1FF; overflow:auto; max-height: 240px; white-space: pre-wrap; word-break: break-word;">[]</pre>
    </div>
  </div>
  <script>
    const ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/debug');
    
    // WebSocket connection status
    const wsStatus = document.getElementById('wsStatus');
    
    ws.onopen = () => {
        wsStatus.textContent = 'WebSocket: Connected';
        wsStatus.style.color = '#8DEB8D';
        wsStatus.style.borderColor = '#8DEB8D';
    };
    
    ws.onclose = () => {
        wsStatus.textContent = 'WebSocket: Disconnected';
        wsStatus.style.color = '#FF6B6B';
        wsStatus.style.borderColor = '#FF6B6B';
    };
    
    ws.onerror = (error) => {
        wsStatus.textContent = 'WebSocket: Error';
        wsStatus.style.color = '#FF6B6B';
        wsStatus.style.borderColor = '#FF6B6B';
    };
    const map = document.getElementById('map');
    const ctx = map.getContext('2d');
    const W = map.width, H = map.height;
    const ownEl = document.getElementById('own');
    const list = document.getElementById('list');

    function addTorpedoEvent(event) {
      const eventsDiv = document.getElementById('torpedoEvents');
      if (!eventsDiv) return;
      
      const eventDiv = document.createElement('div');
      eventDiv.style.padding = '4px 8px';
      eventDiv.style.margin = '2px 0';
      eventDiv.style.borderRadius = '4px';
      eventDiv.style.fontSize = '11px';
      
      let text = '';
      let bgColor = '#1A1A2E';
      
      switch(event.type) {
        case 'torpedo.armed':
          text = `🚀 ${event.name} ARMED`;
          bgColor = '#FF4444';
          break;
        case 'torpedo.detonated':
          text = `💥 ${event.name} HIT ${event.target} at ${event.range_m.toFixed(0)}m`;
          bgColor = '#FF0000';
          break;
        case 'torpedo.self_destruct':
          text = `⚠️ ${event.name} SELF-DESTRUCT: ${event.reason}`;
          bgColor = '#FF8800';
          break;
        case 'torpedo.spoofed':
          text = `🎭 ${event.name} SPOOFED for ${event.seconds}s`;
          bgColor = '#FFAA00';
          break;
        default:
          text = `❓ ${event.type}`;
          bgColor = '#666666';
      }
      
      eventDiv.textContent = text;
      eventDiv.style.backgroundColor = bgColor;
      eventDiv.style.color = '#FFFFFF';
      
      // Add timestamp
      const time = new Date().toLocaleTimeString();
      eventDiv.title = `Time: ${time}`;
      
      // Add to top of list
      eventsDiv.insertBefore(eventDiv, eventsDiv.firstChild);
      
      // Keep only last 10 events
      while (eventsDiv.children.length > 10) {
        eventsDiv.removeChild(eventsDiv.lastChild);
      }
    }

    function drawShip(x,y,heading,color,label){
      ctx.save();
      ctx.translate(x,y);
      // Canvas default points to +X (east). Our headings are compass (0=N,90=E,180=S,270=W).
      // With worldToScreen inverting Y for drawing, keep rotation as (heading - 90)
      ctx.rotate((heading - 90) * Math.PI/180);
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(16,0); ctx.lineTo(-10,6); ctx.lineTo(-10,-6); ctx.closePath();
      ctx.fill();
      ctx.restore();
      ctx.fillStyle = '#89B4FA';
      ctx.fillText(label, x+8, y-8);
    }

    function render(data){
      // Center on ownship, scale to include all ships with padding
      const cx = data.ownship.x, cy = data.ownship.y;
      const pad = 200;
      let maxDx = 100, maxDy = 100;
      data.ships.forEach(s => { maxDx = Math.max(maxDx, Math.abs(s.x - cx)); maxDy = Math.max(maxDy, Math.abs(s.y - cy)); });
      const spanX = maxDx * 2 + pad;
      const spanY = maxDy * 2 + pad;
      function worldToScreen(wx, wy){
        const sx = (wx - cx) / spanX * (W*0.8) + W/2;
        // Invert Y so that positive world Y (north) appears upward on screen
        const sy = H/2 - (wy - cy) / spanY * (H*0.8);
        return [sx, sy];
      }
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = '#050814'; ctx.fillRect(0,0,W,H);
      ctx.strokeStyle = '#1B2440'; ctx.lineWidth = 1;
      for(let i=0;i<8;i++){ ctx.beginPath(); ctx.moveTo(0, i*H/8); ctx.lineTo(W, i*H/8); ctx.stroke(); }
      for(let i=0;i<12;i++){ ctx.beginPath(); ctx.moveTo(i*W/12, 0); ctx.lineTo(i*W/12, H); ctx.stroke(); }

      // Ownship fixed at center
      const [ox, oy] = worldToScreen(data.ownship.x, data.ownship.y);
      const ownDamage = data.ownship.damage || {hull: 0, flooding_rate: 0};
      const ownDamageText = `OWN hdg ${data.ownship.heading.toFixed(0)} spd ${data.ownship.speed.toFixed(1)} dpt ${data.ownship.depth.toFixed(0)} | HULL ${(ownDamage.hull * 100).toFixed(0)}% FLD ${ownDamage.flooding_rate.toFixed(1)}`;
      drawShip(ox, oy, data.ownship.heading, '#6EE7A7', ownDamageText);

      // Clear list before adding new items
      list.innerHTML = '';

      // Draw torpedoes
      if (data.torpedoes && data.torpedoes.length > 0) {
        data.torpedoes.forEach(t => {
          const [tx, ty] = worldToScreen(t.x, t.y);
          // Draw torpedo as a small red triangle pointing in direction of travel
          ctx.save();
          ctx.translate(tx, ty);
          ctx.rotate((t.heading - 90) * Math.PI/180);
          ctx.fillStyle = t.armed ? '#FF4444' : '#FF8888'; // Red when armed, lighter when not
          ctx.beginPath();
          ctx.moveTo(8, 0); ctx.lineTo(-4, 3); ctx.lineTo(-4, -3); ctx.closePath();
          ctx.fill();
          ctx.restore();
          
          // Draw tracking line to target if armed and tracking
          if (t.armed && t.target_id) {
            const target = data.ships.find(s => s.id === t.target_id);
            if (target) {
              const [targetX, targetY] = worldToScreen(target.x, target.y);
              ctx.strokeStyle = t.armed ? '#FF4444' : '#FF8888';
              ctx.lineWidth = 2;
              ctx.setLineDash([5, 5]);
              ctx.beginPath();
              ctx.moveTo(tx, ty);
              ctx.lineTo(targetX, targetY);
              ctx.stroke();
              ctx.setLineDash([]);
              ctx.lineWidth = 1;
            }
          }
          
          // Add torpedo info to list
          const li = document.createElement('div');
          li.className = 'pill';
          li.style.borderColor = t.armed ? '#FF4444' : '#FF8888';
          const status = t.armed ? 'ARMED' : 'ENABLING';
          const target = t.target_id || 'SEARCHING';
          li.textContent = `TORP ${t.name} ${status} hdg ${t.heading.toFixed(0)} spd ${t.speed.toFixed(1)} target: ${target}`;
          li.title = `Range: ${((t.x - data.ownship.x)**2 + (t.y - data.ownship.y)**2)**0.5.toFixed(0)}m | Run time: ${t.run_time.toFixed(1)}s`;
          list.appendChild(li);
        });
      }

      // Draw depth charges as open circles at current XY; color by state
      if (data.depth_charges && data.depth_charges.length > 0) {
        data.depth_charges.forEach(dc => {
          const [dx, dy] = worldToScreen(dc.x, dc.y);
          const exploded = !!dc.exploded;
          ctx.beginPath();
          ctx.arc(dx, dy, 6, 0, Math.PI * 2);
          ctx.strokeStyle = exploded ? '#FF6B6B' : '#6EE7A7';
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.lineWidth = 1;
        });
      }

      // Enemies
      data.ships.forEach(s => {
        const [sx, sy] = worldToScreen(s.x, s.y);
        const shipDamage = s.damage || {hull: 0, flooding_rate: 0};
        const damageText = `${s.id} | HULL ${(shipDamage.hull * 100).toFixed(0)}% FLD ${shipDamage.flooding_rate.toFixed(1)}`;
        drawShip(sx, sy, s.heading, '#E87979', damageText);
        // Bearing line from ownship
        ctx.strokeStyle = '#E87979';
        ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(sx, sy); ctx.stroke();
        const li = document.createElement('div');
        li.className = 'pill';
        const bTrue = (s.bearing_true ?? 0).toFixed(0);
        const bRel = (s.bearing_rel ?? 0).toFixed(0);
        const rng = (s.range_from_own ?? 0).toFixed(0);
        const det = Math.round(((s.passiveDetect || 0) * 100));
        li.textContent = `${s.id} hdg ${s.heading.toFixed(0)} spd ${s.speed.toFixed(1)} dpt ${s.depth.toFixed(0)} brgT ${bTrue} brgR ${bRel} rng ${rng} detect ${det}% | HULL ${(shipDamage.hull * 100).toFixed(0)}% FLD ${shipDamage.flooding_rate.toFixed(1)}`;
        // Color pip based on detectability
        if (det >= 70) { li.style.color = '#FF6B6B'; }
        else if (det >= 40) { li.style.color = '#FACC15'; }
        else { li.style.color = '#8DEB8D'; }
        li.title = `Passive detect: ${det}%  | snrDb: ${((s.snrDb||0)).toFixed(1)} | Hull damage: ${(shipDamage.hull * 100).toFixed(0)}% | Flooding: ${shipDamage.flooding_rate.toFixed(1)}`;
        list.appendChild(li);
      });
    }

    ws.onmessage = (ev) => { 
      try { 
        const m = JSON.parse(ev.data); 
        if (m.topic === 'telemetry') { 
          ownEl.textContent = `hdg ${m.data.ownship.heading.toFixed(0)} spd ${m.data.ownship.speed.toFixed(1)} dpt ${m.data.ownship.depth.toFixed(0)}`; 
          
          // Update noise information display
          const noiseInfo = document.getElementById('noiseInfo');
          if (noiseInfo && m.data.noise) {
            const noise = m.data.noise;
            const acoustics = m.data.acoustics || {};
            noiseInfo.innerHTML = `
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
                <div>Total: <span style="color: #FBBF24;">${noise.total_dB?.toFixed(1) || '0.0'} dB</span></div>
                <div>EMCON: <span style="color: ${acoustics.emconRisk === 'high' ? '#FF6B6B' : acoustics.emconRisk === 'med' ? '#FBBF24' : '#8DEB8D'};">${acoustics.emconRisk || 'low'}</span></div>
                <div>Helm: ${noise.helm_dB?.toFixed(1) || '0.0'} dB</div>
                <div>Sonar: ${noise.sonar_dB?.toFixed(1) || '0.0'} dB</div>
                <div>Weapons: ${noise.weapons_dB?.toFixed(1) || '0.0'} dB</div>
                <div>Engineering: ${noise.engineering_dB?.toFixed(1) || '0.0'} dB</div>
                <div>Budget: <span style="color: ${acoustics.noiseBudget >= 75 ? '#FF6B6B' : acoustics.noiseBudget >= 40 ? '#FBBF24' : '#8DEB8D'};">${acoustics.noiseBudget?.toFixed(0) || '0'}%</span></div>
                <div>Detect: <span style="color: ${acoustics.detectability >= 0.7 ? '#FF6B6B' : acoustics.detectability >= 0.4 ? '#FBBF24' : '#8DEB8D'};">${(acoustics.detectability * 100)?.toFixed(0) || '0'}%</span></div>
                <div>Source Level: <span style="color: #60A5FA;">${acoustics.dynamicSourceLevel?.toFixed(1) || '0.0'} dB</span></div>
                <div>Base Level: ${acoustics.baseSourceLevel?.toFixed(1) || '0.0'} dB</div>
                <div>Noise Contrib: ${acoustics.noiseContributions?.toFixed(1) || '0.0'}</div>
                <div>Station Contrib: ${acoustics.stationNoiseContrib?.toFixed(1) || '0.0'}</div>
              </div>
            `;
          }
          
          render(m.data); 
          // Update truth JSON of ships
          try {
            const box = document.getElementById('shipsJson');
            if (box) { box.textContent = JSON.stringify(m.data.ships || [], null, 2); }
          } catch {}
          
          // Handle torpedo events
          if (m.data.events) {
            m.data.events.forEach(event => {
              if (event.type && event.type.startsWith('torpedo.')) {
                addTorpedoEvent(event);
              }
            });
          }
          // Render RED contact history (sensor-only reports used by Fleet Commander)
          if (Array.isArray(m.data.contactHistory)) {
            const ch = document.getElementById('contactHistory');
            if (ch) {
              const items = m.data.contactHistory.slice(-50).reverse();
              ch.innerHTML = '';
              items.forEach(e => {
                const row = document.createElement('div');
                row.className = 'pill';
                // Type-based color cue
                const t = (e.type || '').toLowerCase();
                row.style.borderColor = t === 'visual' ? '#8DEB8D' : (t === 'active' ? '#FBBF24' : '#60A5FA');
                const ts = e.time ? new Date(e.time).toLocaleTimeString() : '';
                const id = e.id || 'Unknown';
                const bearing = (typeof e.bearing === 'number') ? `${e.bearing.toFixed(0)}°` : '—';
                // Fix range display - show range if available, otherwise show "—"
                const rng = (typeof e.range_est === 'number' && e.range_est > 0) ? `${Math.round(e.range_est)}m` : '—';
                const conf = (typeof e.confidence === 'number') ? (e.confidence*100).toFixed(0)+'%' : '—';
                const cls = e.classifiedAs || e.class || 'Unknown';
                const reporter = e.reportedBy || 'RED';
                row.textContent = `${ts} [${reporter}] ${t.toUpperCase()} id ${id} brg ${bearing} rng ${rng} conf ${conf} class ${cls}`;
                ch.appendChild(row);
              });
            }
          }
          
          const maint = (m.data.maintenance && typeof m.data.maintenance.spawnsEnabled === 'boolean') ? m.data.maintenance.spawnsEnabled : true; 
          const maintState = document.getElementById('maintState'); 
          maintState.textContent = maint ? 'ON' : 'OFF'; 
          maintState.style.color = maint ? '#8DEB8D' : '#FF6B6B';
          
          // Update visual detection toggle states
          const debugToggles = m.data.debugToggles || {};
          const playerVisual = debugToggles.playerVisual100 || false;
          const enemyVisual = debugToggles.enemyVisual100 || false;
          
          const playerVisualState = document.getElementById('playerVisualState');
          playerVisualState.textContent = playerVisual ? 'ON' : 'OFF';
          playerVisualState.style.color = playerVisual ? '#8DEB8D' : '#FF6B6B';
          
          const enemyVisualState = document.getElementById('enemyVisualState');
          enemyVisualState.textContent = enemyVisual ? 'ON' : 'OFF';
          enemyVisualState.style.color = enemyVisual ? '#8DEB8D' : '#FF6B6B'; 
        } 
      } catch(e){} 
    };
    document.getElementById('restart').onclick = () => {
      const sel = document.getElementById('mission');
      const mission = sel && sel.value ? sel.value : 'patrol';
      if (mission === 'patrol') {
        ws.send(JSON.stringify({topic:'debug.restart', data:{}}));
      } else if (mission === 'surface_training') {
        ws.send(JSON.stringify({topic:'debug.restart', data:{}}));
      } else {
        ws.send(JSON.stringify({topic:'debug.restart', data:{}}));
      }
    };
    // Populate mission dropdown from server assets
    fetch('/api/missions').then(r=>r.json()).then(j=>{
      const sel = document.getElementById('mission');
      if (!sel || !j || !Array.isArray(j.missions)) return;
      j.missions.forEach(id => {
        if (id === 'surface_training') return; // already present by default
        const opt = document.createElement('option');
        opt.value = id; opt.textContent = `${id} (assets)`;
        sel.appendChild(opt);
      });
    }).catch(()=>{});
    document.getElementById('toggleMaint').onclick = () => {
      const isOn = (document.getElementById('maintState').textContent || 'ON') === 'ON';
      const next = !isOn;
      ws.send(JSON.stringify({topic:'debug.maintenance.spawns', data:{enabled: next}}));
    };
    
    document.getElementById('togglePlayerVisual').onclick = () => {
      const isOn = (document.getElementById('playerVisualState').textContent || 'OFF') === 'ON';
      const next = !isOn;
      ws.send(JSON.stringify({topic:'debug.visual.player_100', data:{enabled: next}}));
    };
    
    document.getElementById('toggleEnemyVisual').onclick = () => {
      const isOn = (document.getElementById('enemyVisualState').textContent || 'OFF') === 'ON';
      const next = !isOn;
      ws.send(JSON.stringify({topic:'debug.visual.enemy_100', data:{enabled: next}}));
    };
  </script>
</body>
</html>
