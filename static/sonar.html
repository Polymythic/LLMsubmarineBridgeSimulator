<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sonar</title>
  <style>
    body { background:#0B1020; color:#D7E3FF; font-family: ui-sans-serif, system-ui, -apple-system; }
    .panel { background:#11172B; border:1px solid #1B2440; padding:16px; margin:12px; border-radius:8px; }
    button { margin-top:12px; padding:8px 12px; background:#26406E; border:none; color:#D7E3FF; border-radius:6px; }
    ul { list-style:none; padding-left:0; }
    li { margin:4px 0; }
    .row { display:flex; gap:16px; }
    .col { flex:1; }
    #legend { width:100%; height:24px; background:#0B1020; border:1px solid #1B2440; border-radius:6px; margin-bottom:6px; }
    #waterfall { width:100%; height:220px; background:#050814; border:1px solid #1B2440; border-radius:6px; }
    .label { font-size:12px; opacity:0.8; }
  </style>
</head>
<body>
  <div class="panel">
    <h2>Sonar <span class="pill" id="wsStatus" title="WebSocket connection status" style="margin-left: 8px; font-size: 14px; font-weight: normal;">WebSocket: Connecting...</span></h2>
    <div class="row">
      <div class="col">
        <button id="ping" title="Send an active ping; reveals ownship and returns noisy range+bearing">Active Ping</button>
        <div title="Ping cooldown in seconds">Ping cooldown: <span id="cd">0</span>s</div>
        <div class="label" title="Current EMCON risk from acoustics">EMCON: <span id="emcon">low</span></div>
        <h3>Contacts</h3>
        <ul id="contacts" title="Bearing-only passive contacts"></ul>
        <h3>Ping Responses</h3>
        <ul id="pingResponses" title="Last active ping responses"></ul>
      </div>
      <div class="col">
        <div class="label" title="Bearing axis centered at 0¬∞; time flows downward">Passive Waterfall</div>
        <canvas id="legend" width="720" height="24" title="Bearing ticks (270 | 0 | 90)"></canvas>
        <canvas id="waterfall" width="720" height="220" title="Bearing-time-intensity display (0¬∞ centered)"></canvas>
        <div style="display:flex; align-items:flex-end; gap:8px; margin-top:8px;">
          <div class="label">Sonar Noise: <span id="sonarNoise">0</span> dB</div>
          <div id="dbWrap" style="width:30px;height:120px;border:1px solid #1B2440;background:#0B1020;position:relative;border-radius:4px;">
            <div id="dbFill" style="position:absolute;bottom:0;left:0;right:0;background:linear-gradient(180deg,#8DEB8D 0%, #FACC15 60%, #EF4444 100%);height:0px;"></div>
            <div id="dbPeak" style="position:absolute;left:0;right:0;height:3px;background:#FF6B6B;box-shadow:0 0 6px rgba(255,107,107,0.8);bottom:0px;"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="panel" style="width:100%;">
      <h3>Maintenance</h3>
      <div class="row" id="tasksRow">
        <div class="label" id="task" title="Current maintenance tasks">No Active Tasks</div>
      </div>
      
    </div>
    <pre id="telemetry" title="Station telemetry and events"></pre>
  </div>
  <script>
    const ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/sonar');
    
    // WebSocket connection status
    const wsStatus = document.getElementById('wsStatus');
    
    ws.onopen = () => {
        wsStatus.textContent = 'WebSocket: Connected';
        wsStatus.style.color = '#8DEB8D';
        wsStatus.style.borderColor = '#8DEB8D';
    };
    
    ws.onclose = () => {
        wsStatus.textContent = 'WebSocket: Disconnected';
        wsStatus.style.color = '#FF6B6B';
        wsStatus.style.borderColor = '#FF6B6B';
    };
    
    ws.onerror = (error) => {
        wsStatus.textContent = 'WebSocket: Error';
        wsStatus.style.color = '#FF6B6B';
        wsStatus.style.borderColor = '#FF6B6B';
    };
    

    
    
    const tel = document.getElementById('telemetry');
    const cd = document.getElementById('cd');
    const list = document.getElementById('contacts');
    const prList = document.getElementById('pingResponses');
    const emcon = document.getElementById('emcon');
    const sonarNoise = document.getElementById('sonarNoise');
    const dbWrap = document.getElementById('dbWrap');
    const dbFill = document.getElementById('dbFill');
    const dbPeak = document.getElementById('dbPeak');
    let peakHold = 0;
    function setDbMeter(db){
      const h = dbWrap.clientHeight || 120;
      const clamped = Math.max(0, Math.min(100, db));
      const px = Math.floor((clamped/100)*h);
      dbFill.style.height = px + 'px';
      peakHold = Math.max(peakHold - 1, px);
      dbPeak.style.bottom = (peakHold-2) + 'px';
    }

    const legend = document.getElementById('legend');
    const lctx = legend.getContext('2d');
    const lW = legend.width; const lH = legend.height;

    const canvas = document.getElementById('waterfall');
    const ctx = canvas.getContext('2d');
    const W = canvas.width; // 720 px
    const H = canvas.height; // 220 px

    // Map bearing (0..360) to x with 0¬∞ in the middle
    function xForBearing(b, width){
      const rel = (((b + 180) % 360) + 360) % 360; // 0..360 where 180 is left edge, 0 is center
      // shift so rel=180 -> x=0, rel=0 -> x=width/2, rel=360-> x=width
      return Math.floor((rel / 360) * width);
    }

    function drawLegend(){
      lctx.clearRect(0,0,lW,lH);
      lctx.fillStyle = '#0B1020';
      lctx.fillRect(0,0,lW,lH);
      lctx.strokeStyle = '#1B2440';
      lctx.beginPath(); lctx.moveTo(0, lH-0.5); lctx.lineTo(lW, lH-0.5); lctx.stroke();
      const majors = [270, 0, 90];
      const minors = [];
      for (let b=0; b<360; b+=30){ if (!majors.includes(b)) minors.push(b); }
      lctx.fillStyle = '#8593B8'; lctx.font = '12px ui-sans-serif';
      lctx.strokeStyle = '#2A345C';
      minors.forEach(b => { const x = xForBearing(b, lW); lctx.beginPath(); lctx.moveTo(x+0.5, lH-10); lctx.lineTo(x+0.5, lH-2); lctx.stroke(); });
      lctx.strokeStyle = '#4C5E9A';
      majors.forEach(b => { const x = xForBearing(b, lW); lctx.beginPath(); lctx.moveTo(x+0.5, lH-16); lctx.lineTo(x+0.5, lH-2); lctx.stroke(); lctx.textAlign='center'; lctx.fillText(String(b), x, 12); });
      // Legend keys
      lctx.fillStyle = '#00E5FF'; lctx.fillRect(6, 6, 18, 3); lctx.fillStyle = '#D7E3FF'; lctx.fillText('Own Ping', 28, 12);
      lctx.strokeStyle = '#FF4DFF'; lctx.setLineDash([4,3]); lctx.beginPath(); lctx.moveTo(110, 7.5); lctx.lineTo(128, 7.5); lctx.stroke(); lctx.setLineDash([]); lctx.fillStyle = '#D7E3FF'; lctx.fillText('Enemy Ping', 134, 12);
      lctx.fillStyle = '#FF7A00'; lctx.fillRect(240, 6, 18, 5); lctx.fillStyle = '#D7E3FF'; lctx.fillText('Explosion', 264, 12);
    }

    drawLegend();

    let row = 0;

    function drawWaterfall(contacts, pingResponses, explosions){
      const imageData = ctx.createImageData(W, 1);
      const data = imageData.data;
      for (let x = 0; x < W; x++){
        const idx = x * 4; data[idx+0] = 9; data[idx+1] = 14; data[idx+2] = 28; data[idx+3] = 255;
      }
      (contacts || []).forEach(c => {
        const bearing = ((c.bearing % 360) + 360) % 360;
        const x = xForBearing(bearing, W);
        const strength = Math.max(0, Math.min(1, (c.detectability != null ? c.detectability : c.strength) || 0));
        const glow = Math.floor(60 + strength * 180);
        for (let dx = -1; dx <= 1; dx++){
          const xi = Math.max(0, Math.min(W-1, x + dx));
          const base = xi * 4;
          data[base+0] = glow; data[base+1] = Math.floor(glow * 0.85); data[base+2] = Math.floor(glow * 0.4); data[base+3] = 255;
        }
      });
      // Active ping dots: brighter by strength
      (pingResponses || []).forEach(p => {
        const bearing = ((p.bearing % 360) + 360) % 360;
        const x = xForBearing(bearing, W);
        const strength = Math.max(0, Math.min(1, p.strength || 0));
        const glow = Math.floor(80 + strength * 175);
        const base = x * 4;
        data[base+0] = Math.max(data[base+0], glow);
        data[base+1] = Math.max(data[base+1], Math.floor(glow * 0.6));
        data[base+2] = Math.max(data[base+2], Math.floor(glow * 0.2));
        data[base+3] = 255;
      });
      ctx.putImageData(imageData, 0, row);
      // Overlays: explosions (thick orange), own ping (thin cyan), enemy ping (thin magenta dashed) can be future
      (explosions || []).forEach(e => {
        const bearing = ((e.bearing % 360) + 360) % 360;
        const x = xForBearing(bearing, W);
        ctx.save();
        ctx.strokeStyle = '#FF7A00';
        ctx.lineWidth = 3.5;
        ctx.beginPath();
        ctx.moveTo(x + 0.5, row - 6);
        ctx.lineTo(x + 0.5, row + 6);
        ctx.stroke();
        ctx.restore();
      });
      row = (row + 1) % H;
    }

    // Track existing task elements by ID to avoid recreation
    let existingTaskElements = new Map();
    
    ws.onmessage = (ev) => {
      try {
        const m = JSON.parse(ev.data);
        if (m.topic === 'telemetry') {
          tel.textContent = JSON.stringify(m.data, null, 2);
          cd.textContent = (m.data.pingCooldown || 0).toFixed(1);
          if (m.data.acoustics) { emcon.textContent = (m.data.acoustics.emconRisk || 'low'); }
          const nz = (m.data.noise && m.data.noise.sonar_dB) || 0; sonarNoise.textContent = nz.toFixed(0); setDbMeter(nz);
          
          const tasks = m.data.tasks || [];
          console.log('üîß Processing tasks:', tasks);
          console.log('üîç Tasks array length:', tasks.length);
          console.log('üîç Tasks array type:', typeof tasks);
          console.log('üîç Tasks array content:', JSON.stringify(tasks, null, 2));
          
          // Smart task update: only create new elements for new tasks
          const row = document.getElementById('tasksRow');
          
          if (tasks.length === 0) {
            console.log('üìù No tasks found, showing default message');
            // Clear all existing tasks
            existingTaskElements.clear();
            row.innerHTML = '';
            const el = document.createElement('div');
            el.className = 'label';
            el.id = 'task';
            el.textContent = 'No Active Tasks';
            el.style.color = '#D7E3FF';
            row.appendChild(el);
          } else {
            console.log('üìù Found', tasks.length, 'tasks, processing them...');
            // Process each task
            // Remove placeholder if present
            const placeholder = document.getElementById('task');
            if (placeholder) {
              placeholder.parentElement && placeholder.parentElement.removeChild(placeholder);
            }
            // Remove any tasks that no longer exist
            const currentIds = new Set(tasks.map(t => t.id));
            for (const [tid, el] of Array.from(existingTaskElements.entries())) {
              if (!currentIds.has(tid)) {
                if (el && el.parentElement) el.parentElement.removeChild(el);
                existingTaskElements.delete(tid);
              }
            }
            tasks.forEach((task, index) => {
              console.log('üîç Processing task', index + 1, 'of', tasks.length, ':', task);
              console.log('üîç Task ID:', task.id);
              console.log('üîç Task title:', task.title);
              const taskId = task.id;
              
              console.log('üîç Checking if task exists in existingTaskElements:', taskId);
              console.log('üîç existingTaskElements size:', existingTaskElements.size);
              console.log('üîç existingTaskElements keys:', Array.from(existingTaskElements.keys()));
              
              console.log('üîç existingTaskElements.has(taskId) result:', existingTaskElements.has(taskId));
              console.log('üîç taskId value:', taskId);
              console.log('üîç taskId type:', typeof taskId);
              
              if (existingTaskElements.has(taskId)) {
                // Update existing task element
                console.log('üîÑ Updating existing task:', taskId);
                const existingEl = existingTaskElements.get(taskId);
                const label = task.stage === 'task' ? 'MAINTENANCE' : (task.stage === 'failing' ? 'FAILING' : 'FAILED');
                
                // Update only the text content, preserve the button
                const textSpan = existingEl.querySelector('.task-text');
                if (textSpan) {
                  textSpan.textContent = `üîß ${task.title} ‚Äî ${label} ${(task.progress*100).toFixed(0)}% ‚Äî time to complete ${Math.max(0, task.time_remaining_s).toFixed(0)}s${task.started ? ' (REPAIRING)' : ''}`;
                }
              } else {
                // Create new task element
                console.log('üÜï Creating new task element:', taskId);
                console.log('üÜï About to create DOM elements...');
                
                const el = document.createElement('div');
                el.className = 'label';
                const color = task.stage === 'task' ? '#FACC15' : (task.stage === 'failing' ? '#F59E0B' : '#EF4444');
                const bg = task.stage === 'task' ? 'rgba(250, 204, 21, 0.1)' : (task.stage === 'failing' ? 'rgba(245, 158, 11, 0.1)' : 'rgba(239, 68, 68, 0.1)');
                el.style.color = color;
                el.style.backgroundColor = bg;
                
                const label = task.stage === 'task' ? 'MAINTENANCE' : (task.stage === 'failing' ? 'FAILING' : 'FAILED');
                
                // Create repair button for this specific task
                const btn = document.createElement('button');
                btn.textContent = 'Repair';
                btn.style.marginLeft = '8px';
                
                // Capture the task ID directly to avoid closure issues
                
                // Add basic click logging to diagnose the issue
                console.log('üîß Creating repair button for task:', taskId);
                
                btn.onclick = () => {
                  console.log('üñ±Ô∏è BUTTON CLICKED! Sonar task repair button clicked for task:', taskId);
                  console.log('üîç Button element:', btn);
                  console.log('üîç Button onclick property:', btn.onclick);
                  
                  const cmd = {topic: 'station.task.start', data: {station: 'sonar', task_id: taskId}};
                  console.log('üì§ Sending sonar task repair command:', cmd);
                  try {
                    ws.send(JSON.stringify(cmd));
                    console.log('üì§ Sonar task repair command sent successfully');
                  } catch (error) {
                    console.error('‚ùå Error sending sonar task repair command:', error);
                  }
                };
                
                // Verify the handler was attached
                console.log('üîç Button onclick after setup:', btn.onclick);
                
                // Create a span for the text content
                const textSpan = document.createElement('span');
                textSpan.className = 'task-text';
                textSpan.textContent = `üîß ${task.title} ‚Äî ${label} ${(task.progress*100).toFixed(0)}% ‚Äî time to complete ${Math.max(0, task.time_remaining_s).toFixed(0)}s${task.started ? ' (REPAIRING)' : ''}`;
                
                console.log('üÜï Appending text span and button to element...');
                el.appendChild(textSpan);
                el.appendChild(btn);
                console.log('üÜï Appending element to row...');
                row.appendChild(el);
                console.log('üÜï Element appended successfully');
                
                // Store the element for future updates
                console.log('üÜï Storing element in existingTaskElements for task:', taskId);
                existingTaskElements.set(taskId, el);
                console.log('üÜï Element stored successfully');
              }
            });
          }
          
          list.innerHTML = '';
          (m.data.contacts || []).forEach(c => {
            const li = document.createElement('li');
            li.title = 'Passive contact; bearing-only with noisy measurement.';
            const bearingText = (c.bearingKnown ? `${c.bearing.toFixed(0)}¬∞` : 'unknown');
            const det = (c.detectability != null ? c.detectability : c.strength);
            li.textContent = `ID ${c.id} brg ${bearingText} det ${det.toFixed(2)} conf ${c.confidence.toFixed(2)}`;
            list.appendChild(li);
          });
          prList.innerHTML = '';
          (m.data.pingResponses || []).forEach(p => { const li = document.createElement('li'); li.title = 'Active ping response'; const km = (p.range_est/1000).toFixed(1); li.textContent = `ID ${p.id} brg ${p.bearing.toFixed(0)}¬∞ range ~${km} km str ${(+p.strength).toFixed(2)} at ${p.at}`; prList.appendChild(li); });
          drawWaterfall(m.data.contacts || [], m.data.pingResponses || [], m.data.explosions || []);
        }
      } catch(e){}
    };

    document.getElementById('ping').onclick = () => { ws.send(JSON.stringify({topic:'sonar.ping', data:{array:'bow'}})); };
  </script>
</body>
</html>
