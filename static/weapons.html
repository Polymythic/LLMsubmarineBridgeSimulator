<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Weapons</title>
  <style>
    body { background:#0B1020; color:#D7E3FF; font-family: ui-sans-serif, system-ui, -apple-system; }
    .panel { background:#11172B; border:1px solid #1B2440; padding:16px; margin:12px; border-radius:8px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    label { display:block; margin-top:8px; }
    input { width:100%; background:#0F162A; color:#D7E3FF; border:1px solid #1B2440; padding:8px; }
    button { margin-top:12px; padding:8px 12px; background:#26406E; border:none; color:#D7E3FF; border-radius:6px; }
    .tubes { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:8px; }
    .tube { padding:8px; border:1px solid #1B2440; border-radius:6px; background:#0F162A; }
    .small { opacity:0.8; font-size:12px; }
    #dbWrap { width: 30px; height: 160px; border:1px solid #1B2440; background:#0B1020; position: relative; border-radius:4px; }
    #dbFill { position:absolute; bottom:0; left:0; right:0; background: linear-gradient(180deg, #8DEB8D 0%, #FACC15 60%, #EF4444 100%); }
    #dbPeak { position:absolute; left:0; right:0; height:3px; background:#FF6B6B; box-shadow:0 0 6px rgba(255,107,107,0.8); }
  </style>
</head>
<body>
  <div class="panel">
    <h2>Weapons <span class="pill" id="wsStatus" title="WebSocket connection status" style="margin-left: 8px; font-size: 14px; font-weight: normal;">WebSocket: Connecting...</span></h2>
    <div id="consent" title="Captain consent requirement before firing"></div>
    <div class="tubes" id="tubes" title="Tube state machine: Empty‚ÜíFlooded‚ÜíDoorsOpen; timers show progress."></div>
    <div class="row" style="align-items: flex-end;">
      <div class="small">Weapons Noise: <span id="weapNoise">0</span> dB</div>
      <div id="dbWrap" title="Weapons noise">
        <div id="dbFill" style="height:0px;"></div>
        <div id="dbPeak" style="bottom:0px;"></div>
      </div>
    </div>
    <div class="panel" style="width:100%;">
      <h3>Maintenance</h3>
      <div class="row" id="tasksRow">
        <div class="small" id="task" title="Current maintenance tasks">No Active Tasks</div>
      </div>
      
    </div>
    <label title="Select a tube to operate">Tube <input id="tube" type="number" min="1" max="6" value="1"></label>
    <div>
      <button id="load" title="Load a torpedo into the selected tube (starts reload timer)">Load</button>
      <button id="flood" title="Flood the selected tube (makes it ready to open)">Flood</button>
      <button id="doors" title="Open outer doors on the selected tube (required to fire)">Open Doors</button>
    </div>
    <label title="Set bearing to fire along">Bearing <input id="bearing" type="number" min="0" max="359" value="270"></label>
    <label title="Set commanded torpedo run depth">Run Depth <input id="rdepth" type="number" min="0" max="600" value="120"></label>
    <label title="Seeker enable range (m)">Enable Range <input id="enable" type="number" min="100" max="8000" step="100" value="1500"></label>
    <label title="Guidance doctrine">Doctrine
      <select id="doctrine">
        <option value="passive_then_active" selected>Passive‚ÜíActive</option>
      </select>
    </label>
    <button id="fire" title="Fire the selected tube (interlocks apply)">Fire</button>
    
    <div style="margin-top: 20px; padding: 16px; border: 2px solid #FF4444; border-radius: 8px; background: rgba(255, 68, 68, 0.1);">
      <h4 style="color: #FF4444; margin: 0 0 12px 0;">üß™ TEST MODE - BYPASS ALL INTERLOCKS</h4>
      <div style="font-size: 12px; color: #FF8888; margin-bottom: 12px;">
        This button launches a torpedo immediately without any tube preparation, captain consent, or other safety checks.
        <br>Use only for testing torpedo tracking and damage systems!
      </div>
      <button id="testFire" title="Launch test torpedo (bypasses all interlocks)" style="background: #FF4444; color: white; font-weight: bold;">üöÄ LAUNCH TEST TORPEDO</button>
    </div>
    
    <pre id="telemetry" title="Weapons telemetry and events"></pre>
  </div>
  <script>
    const ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/weapons');
    
    // WebSocket connection status
    const wsStatus = document.getElementById('wsStatus');
    
    ws.onopen = () => {
        wsStatus.textContent = 'WebSocket: Connected';
        wsStatus.style.color = '#8DEB8D';
        wsStatus.style.borderColor = '#8DEB8D';
    };
    
    ws.onclose = () => {
        wsStatus.textContent = 'WebSocket: Disconnected';
        wsStatus.style.color = '#FF6B6B';
        wsStatus.style.borderColor = '#FF6B6B';
    };
    
    ws.onerror = (error) => {
        wsStatus.textContent = 'WebSocket: Error';
        wsStatus.style.color = '#FF6B6B';
        wsStatus.style.borderColor = '#FF6B6B';
    };
    const tel = document.getElementById('telemetry');
    const tubes = document.getElementById('tubes');
    const consent = document.getElementById('consent');
    const weapNoise = document.getElementById('weapNoise');
    const dbWrap = document.getElementById('dbWrap');
    const dbFill = document.getElementById('dbFill');
    const dbPeak = document.getElementById('dbPeak');
    let peakHold = 0;
    function setDbMeter(db){
      const h = dbWrap.clientHeight || 160;
      const clamped = Math.max(0, Math.min(100, db));
      const px = Math.floor((clamped/100)*h);
      dbFill.style.height = px + 'px';
      peakHold = Math.max(peakHold - 1, px);
      dbPeak.style.bottom = (peakHold-2) + 'px';
    }
    // Track existing task elements by ID to avoid recreation
    let existingTaskElements = new Map();
    
    ws.onmessage = (ev) => {
      try {
        const m = JSON.parse(ev.data);
        if (m.topic === 'telemetry') {
          tel.textContent = JSON.stringify(m.data, null, 2);
          consent.textContent = m.data.consentRequired ? `Captain consent ${m.data.captainConsent ? 'GRANTED' : 'REQUIRED'}` : 'Consent not required';
          tubes.innerHTML = '';
          (m.data.tubes || []).forEach(t => {
            const div = document.createElement('div');
            div.className = 'tube';
            const timer = t.timer_s && t.timer_s > 0 ? ` [${t.timer_s.toFixed(1)}s]` : '';
            const canFlood = t.state === 'Loaded' && (!t.timer_s || t.timer_s <= 0);
            const canDoors = t.state === 'Flooded' && (!t.timer_s || t.timer_s <= 0);
            const canFire = t.state === 'DoorsOpen' && (!t.timer_s || t.timer_s <= 0);
            div.innerHTML = `<div title='Tube state and weapon type'>Tube ${t.idx}: ${t.state} ${t.weapon ? '('+t.weapon.name+')' : ''}</div><div class='small' title='Time remaining on current transition'>Timer${timer}</div><div class='small'>Flood:${canFlood?'YES':'NO'} Doors:${canDoors?'YES':'NO'} Fire:${canFire?'YES':'NO'}</div>`;
            tubes.appendChild(div);
          });
          const nz = (m.data.noise && m.data.noise.weapons_dB) || 0; weapNoise.textContent = nz.toFixed(0); setDbMeter(nz);
          const tasks = m.data.tasks || [];
          console.log('üîß Processing tasks:', tasks);
          console.log('üîç Tasks array length:', tasks.length);
          console.log('üîç Tasks array type:', typeof tasks);
          console.log('üîç Tasks array content:', JSON.stringify(tasks, null, 2));
          
          // Smart task update: only create new elements for new tasks
          const row = document.getElementById('tasksRow');
          
          if (tasks.length === 0) {
            console.log('üìù No tasks found, showing default message');
            // Clear all existing tasks
            existingTaskElements.clear();
            row.innerHTML = '';
            const el = document.createElement('div');
            el.className = 'small';
            el.id = 'task';
            el.textContent = 'No Active Tasks';
            el.style.color = '#D7E3FF';
            el.style.borderColor = '#1B2440';
            el.style.backgroundColor = '#0F162A';
            row.appendChild(el);
          } else {
            console.log('üìù Found', tasks.length, 'tasks, processing them...');
            // Process each task
            // Clear placeholder if present
            const placeholder = document.getElementById('task');
            if (placeholder) {
              placeholder.parentElement && placeholder.parentElement.removeChild(placeholder);
            }
            // Remove any tasks that no longer exist
            const currentIds = new Set(tasks.map(t => t.id));
            for (const [tid, el] of Array.from(existingTaskElements.entries())) {
              if (!currentIds.has(tid)) {
                if (el && el.parentElement) el.parentElement.removeChild(el);
                existingTaskElements.delete(tid);
              }
            }
            tasks.forEach((task, index) => {
              console.log('üîç Processing task', index + 1, 'of', tasks.length, ':', task);
              const taskId = task.id;
              
              if (existingTaskElements.has(taskId)) {
                // Update existing task element
                console.log('üîÑ Updating existing task:', taskId);
                const existingEl = existingTaskElements.get(taskId);
                 const label = task.stage === 'task' ? 'MAINTENANCE' : (task.stage === 'failing' ? 'FAILING' : 'FAILED');
                
                // Update only the text content, preserve the button
                const textSpan = existingEl.querySelector('.task-text');
                if (textSpan) {
                  textSpan.textContent = `üîß ${task.title} ‚Äî ${label} ${(task.progress*100).toFixed(0)}% ‚Äî time to complete ${Math.max(0, task.time_remaining_s).toFixed(0)}s${task.started ? ' (REPAIRING)' : ''}`;
                }
              } else {
                // Create new task element
                console.log('üÜï Creating new task element:', taskId);
                
                const el = document.createElement('div');
                el.className = 'small';
                 const color = task.stage === 'task' ? '#FACC15' : (task.stage === 'failing' ? '#F59E0B' : '#EF4444');
                 const bg = task.stage === 'task' ? 'rgba(250, 204, 21, 0.1)' : (task.stage === 'failing' ? 'rgba(245, 158, 11, 0.1)' : 'rgba(239, 68, 68, 0.1)');
                el.style.color = color;
                el.style.borderColor = color;
                el.style.backgroundColor = bg;
                
                 const label = task.stage === 'task' ? 'MAINTENANCE' : (task.stage === 'failing' ? 'FAILING' : 'FAILED');
                
                // Create repair button for this specific task
                const btn = document.createElement('button');
                btn.textContent = 'Repair';
                btn.style.marginLeft = '8px';
                
                // Capture the task ID directly to avoid closure issues
                
                // Add basic click logging to diagnose the issue
                console.log('üîß Creating weapons repair button for task:', taskId);
                
                btn.onclick = () => {
                  console.log('üñ±Ô∏è BUTTON CLICKED! Weapons task repair button clicked for task:', taskId);
                  console.log('üîç Button element:', btn);
                  console.log('üîç Button onclick property:', btn.onclick);
                  
                  const cmd = {topic: 'station.task.start', data: {station: 'weapons', task_id: taskId}};
                  console.log('üì§ Sending weapons task repair command:', cmd);
                  try {
                    ws.send(JSON.stringify(cmd));
                    console.log('üì§ Weapons task repair command sent successfully');
                  } catch (error) {
                    console.error('‚ùå Error sending weapons task repair command:', error);
                  }
                };
                
                // Verify the handler was attached
                console.log('üîç Button onclick after setup:', btn.onclick);
                
                // Create a span for the text content
                const textSpan = document.createElement('span');
                textSpan.className = 'task-text';
                textSpan.textContent = `üîß ${task.title} ‚Äî ${label} ${(task.progress*100).toFixed(0)}% ‚Äî time to complete ${Math.max(0, task.time_remaining_s).toFixed(0)}s${task.started ? ' (REPAIRING)' : ''}`;
                
                el.appendChild(textSpan);
                el.appendChild(btn);
                row.appendChild(el);
                console.log('üÜï Appended weapons task element to row');
                
                // Store the element for future updates
                existingTaskElements.set(taskId, el);
              }
            });
          }
        }
      } catch(e){}
    };
    const tube = () => parseInt(document.getElementById('tube').value, 10);
    document.getElementById('load').onclick = () => ws.send(JSON.stringify({topic:'weapons.tube.load', data:{tube: tube(), weapon:'Mk48'}}));
    document.getElementById('flood').onclick = () => ws.send(JSON.stringify({topic:'weapons.tube.flood', data:{tube: tube()}}));
    document.getElementById('doors').onclick = () => ws.send(JSON.stringify({topic:'weapons.tube.doors', data:{tube: tube(), open:true}}));
    document.getElementById('fire').onclick = () => {
      const bearing = parseFloat(document.getElementById('bearing').value);
      const run_depth = parseFloat(document.getElementById('rdepth').value);
      const enable_range = parseFloat(document.getElementById('enable').value);
      const doctrine = document.getElementById('doctrine').value;
      ws.send(JSON.stringify({topic:'weapons.fire', data:{tube: tube(), bearing, run_depth, enable_range, doctrine}}));
    };

    // Test torpedo launch - bypasses all interlocks
    document.getElementById('testFire').onclick = () => {
      const bearing = parseFloat(document.getElementById('bearing').value);
      const run_depth = parseFloat(document.getElementById('rdepth').value);
      const enable_range = parseFloat(document.getElementById('enable').value);
      const doctrine = document.getElementById('doctrine').value;
      
      // Visual feedback
      const testBtn = document.getElementById('testFire');
      const originalText = testBtn.textContent;
      testBtn.textContent = 'üöÄ LAUNCHING...';
      testBtn.style.background = '#FF8800';
      
      // Send test torpedo command that bypasses all checks
      ws.send(JSON.stringify({
        topic: 'weapons.test_fire', 
        data: {
          tube: tube(), 
          bearing, 
          run_depth, 
          enable_range, 
          doctrine
        }
      }));
      
      console.log('üß™ Test torpedo launched:', {bearing, run_depth, enable_range, doctrine});
      
      // Reset button after 1 second
      setTimeout(() => {
        testBtn.textContent = originalText;
        testBtn.style.background = '#FF4444';
      }, 1000);
    };

    
    
  </script>
</body>
</html>
